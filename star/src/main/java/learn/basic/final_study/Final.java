package learn.basic.final_study;

/**
 * final 关键字  最终的  不可改变的
 * 常见的四种用法
 *    1.可以用来修饰一个类
 *    2.可以用来修饰一个方法
 *    3.还可以用来修饰一个局部变量
 *    4.还可以用来修饰一个成员变量
 *                           ---不管你用上面四种的哪一种final都是代表最终的  不可改变的
 *
 */
public class Final {


    /*****************************************************final关键字用于修饰类*******************************************************************
     * 含义：当前这个类不能有任何的子类（太监类）  不能有子类来继承它   但是它一定是有父类的就算不知道直接父类是谁 但还有一个Object
     *
     * public final class 类名称{
     *     //。。。。
     * }
     *   用final修饰了之后 方法体里面该怎么写就怎么写  什么构造方法啊  成员变量啊   该怎么写就怎么写  但是不能有儿子
     * 注意： 一个类如果是final的，那么其中所有的成员方法都无法进行进行覆盖重写（因为没儿子） 没有人来继承你   所就呢 就没有人可以对你进行覆盖重写
     *       但是如果我自己是fina类  能不能对我的父类继承下来的方法进行覆盖重写呢  那是可以的
     *       但是到我这里 香火就断了 就不能进行覆盖重写了
     *
     */


    /*****************************************************final关键字用于修饰一个方法*******************************************************************
     *
     * 当final关键字用来修饰一个方法的时候，这个方法就是最终方法。 也就是不能被覆盖重写。
     *
     * 格式：
     *    修饰符  final  返回值类型 方法名称(参数列表){
     *        方法体
     *    }
     *
     *
     * 其实和上面的类差不多吧  只不过呢 整个类都是final的  那就压根不能有子类
     * 你的类是普通的类的  能有子类但是这一个小的方法是final的  那么这一个方法也是不能被覆盖重写的
     *
     *
     * 注意事项：
     *   对于类，方法来说 ，abstract关键字和final关键字不能同时使用，因为矛盾。
     *
     *
     *   抽象方法（abstract） 是没有方法体的 并且抽象方法所在的类必须是抽象类
     *   abstract 一定要被重写   但是final不能被覆盖重写 这两个就是矛盾的
     *
     *
     */


    /*****************************************************final关键字用于修饰一个局部变量*******************************************************************
     *
     * 知识点  见  案例  3
     *
     */

    /*****************************************************final关键字用于修饰一个成员变量*******************************************************************
     *
     *知识点  见  案例  4
     *
     */


}

/********************************************************************1***************************************************************************/
final  class MyClass{
    //当前类有没有父类   --有    是Object  隐含 extends Object


    //能不能对fianl修饰的方法覆盖/重写  可以吗？ 如果是覆盖重写  我就要有子类吧  子类才能进行 Override   但是现在它能有子类吗  没有   所以不可以
    public void method(){
        System.out.println("方法执行");
    }
}

//不能使用一个final类作为父类  强行去写就是错误的
class MySubClass /*extends  MyClass*/{//这样写就报错了  不对  不能继承它 因为它是final的

}

/********************************************************************2***************************************************************************/
class Fu{
    public final void method(){
        System.out.println("父类方法执行");
    }

}

class Zi extends Fu{
    /**错误写法！**/ //不能覆盖重写父类当中final的方法
    /*public void method(){
        System.out.println("子类覆盖重写父类的方法");
    }  */
}
/********************************************************************3***************************************************************************/
class Demo01Final{
    public static void main(String[] args) {
        //对于一个普通的变量来说 内容是可变的这是它主要的特点
        int num1 =10;
        System.out.println(num1);//10
        num1=20;
        System.out.println(num1);//20

        //一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。
        //"一次赋值，终生不变"
        final int num2=200;
        System.out.println(num2);//200

        //尝试改变一下
        // num2=250;//错误写法！不能改变！


        //再赋个值 和前面的200一样
        //  num2=200;//错误写法！ 首先从意义上讲你这么做没必要  其次不要以为编译器会闲着没事干帮你看看和之前一样不一样
                               // 你既然和之前一样 你又何必赋值呢  所以对fianl局部变量只能赋值一次  就算和前面一样 也不行
        //正确写法！只要保证有唯一一次赋值即可
        final int num3;
        num3=30;

        //什么叫做不变
        //对于基本类型来说，不可变说的是变量当中的数据不可改变  例 你是一个 int  或者  double 等  你是几就是几不可改变
        //对于引用类型来说，不可变说的是变量当中的地址值不可改变  （引用类型 它的名称就是一个变量  它的名称当中其实存的是一个什么东西  地址值）


        //创建教师类
        Teacher teacher1 = new Teacher("赵丽颖");
        System.out.println(teacher1);
        System.out.println(teacher1.getName());//赵丽颖

        //那什么叫做能变呢  我现在没有用final
        teacher1 = new Teacher("霍建华");  //重新赋值  赋一个地址值
        System.out.println(teacher1);
        System.out.println(teacher1.getName());//霍建华

        //再以上的代码中  teacher中的地址值发生了改变

        //但是再来上一个final的情况下  就不一样了
        final  Teacher teacher2 = new Teacher("高圆圆");
        //错误写法！ final的引用类型变量，其中的地址不可改变  如果尝试第二次往里面赋值就会报错
        //          我们虽说地址值不可变但是里面的内容是可以变的
        //          什么叫内容呢  我现在叫高圆圆   可以更换其他内容
        //teacher2 = new Teacher("赵又廷");
        System.out.println(teacher2.getName());//原本是高圆圆

        //现在不对这个teacher2对象赋值  你还是哪个teacher2对象  但是对它的name成员变量赋值
        teacher2.setName("高圆圆圆圆");
        //现在它的成员变量name会发生改变
        System.out.println(teacher2.getName());//现在是高圆圆圆圆

        //结论  什么  不能变   是teacher2它的地址值不能发生改白能  但是地址所指向的那个对象（Teacher）肚子里面是改名了啊 还是干啥了  我就都不管了
    }
}
//例  Teacher(教师类)  标准的学生类
class Teacher{

    private String name;

    public Teacher() {

    }

    public Teacher(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {

        return name;
    }
}

/********************************************************************4***************************************************************************/

class  Person {
    /**
     * 对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变
     *
     * 1.由于成员变量具有默认值（如 int-0  引用类型-null）  那么具有这样的默认值   一旦要是默认值被放了进去 这算不算赋值？ 也算赋值！
     *   因为一旦用了final关键字之后 它就不会再给默认值了   所以必须需要手动赋值
     * 2.对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值   ------- 二者选其一
     *
     *     什么叫做直接赋值  就是在    变量名称  =  后面直接写
     * 3.  必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。
     *       如果你不能保证  那你就用直接赋值  压根就别用构造方法赋值  反正时二者选其一的关系
     *
     */

    //错误写法
    //private fianl String name;若添加上final之后会直接报错  为什么呢  我原来也没赋值啊
    //                          因为没有final 它是有默认值的   默认值没final是可以发生改变的  你本来是个null值  我现在往里面放上一个张三
    //                          行不行啊  可以  这不就变了吗  但是如果我要写上一个final  为什么报错  因为一定要手动赋值  它的默认值不会有了
    //                          不是它吝啬 是它不能给你  一旦要是把 null值 默认值放在里面 那它永远就是null了,你在想把它换成什么都不行了 前面是不是又一个final
    private  final String name  /*="鹿晗"*/; //会发现  后面所有代码   凡是尝试对name进行赋值的地方都会报错   它是final的你不能重新赋值啊
                                            //所以说 用了直接赋值  就不能再通过构造赋值  但是你如果通过了构造就不要用直接赋值了 二者选其一

                                             //当取消直接赋值时  采用构造方法进行赋值 这也可以 但是会发现构造有几个  构造有两个
                                             // 全参的确实给它赋值了  你传什么我就赋什么 但是默认构造有没有对name进行赋值呢？ 没有！
                                             // 因此 你必须保证所有的重载形式的构造方法都最终会对final的成员变量进行赋值
                                             //  但是我通过构造方法进行赋值 后面 这setXxx()方法 还能这么写吗  就不能这么写了  注释掉
                                             // 它时final的  时final的  你就不能给他进行赋值  你必须保证所有的构造方法对它都有赋值
    public Person() {

        name="关晓彤";
    }

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

   /* public void setName(String name) {
        this.name = name;
    }*/
}
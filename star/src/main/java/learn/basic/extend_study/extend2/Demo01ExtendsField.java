package learn.basic.extend_study.extend2;


/**
 * 在父子两个类产生了继承关系之后呢  那么如果使用其中的成员变量有怎样的规则
 *
 * 在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：
 *
 * 1.直接通过子类对象访问成员变量（就是new上一个子类对象 直接点（.）它）：
 *
 *         等号左边是谁，就优先用谁，没有则向上找。
 *
 * 2.间接通过成员方法访问成员变量：
 *        该方法属于（就是定义在哪）谁，就优先用谁，没有则向上找  方法在哪  就优先用哪
 *          这是在父子类继承关系当中的 如果你重名了我访问成员变量的规则
 *
 */
public class Demo01ExtendsField {

    public static void main(String[] args) {
        Fu fu = new Fu();//创建父类对象
        //在这种情况下  发现里面只有numFu  有没有numZi呢  没有
        System.out.println(fu.numFu);//只能使用父类的东西，没有任何子类的内容  因为我们创建了一个父类对象  父类就是一个普通的类吧
                                     //每一个父类都是段正淳 不知道自己在哪里还有孩子  只有儿子知道父亲是谁  父亲不知道儿子是谁的

        Zi zi = new Zi();
        //在调用的时候 会看到 numFu  numZi 都有的   子类可以拥有父类继承下来的东西
        //System.out.println(zi.numFu);//10
        //System.out.println(zi.numZi);//20
        System.out.println("====================================");
        //接下来我们让它们重名  你说不重名当然没有问题 很简单啊  关键就在于两个人要是重名了会怎么样

        //子类对象已经创建出来了 直接  点（.）
        //例如

        //等号左边是谁，就优先用谁
        //

        System.out.println(zi.num);// 优先子类   200  这个就叫做直接访问它 直接点它      我不写numFu  也不屑numZi  我就直接 访问num  这就是重名的内容吧
                                    // 你这个zi是怎么创建出来的   Zi zi = new Zi();    等等号左边是谁  左边是谁  是zi   先用子类

                                   //优先子类   200  这个就叫做直接访问它 直接点它   那它万一要是没有呢   比如上面我们访问子类当中的numFu
                                   //你看看Zi类中有没有numFu呢 没有 它就向上找到父类了吧  那要是如果父类当中也没有呢  到处都没有   编译报错
       // System.out.println(zi.abc);//到处都没有   编译报错

        System.out.println("====================================");

        Fu fu1 = new Zi();
        System.out.println(fu1.num);//100优先访问父类  等号左边的是Fu

        System.out.println("====================================");

        zi.methodZi();//这个方法是子类的 那我就优先用子类的，没有在向上找  200就能出来  因为你子类当中有
        //但是如果我要调用父类的methodFu()呢
        // 重点强调  这个方法是谁的  什么叫是谁的   看它的定义在哪
        //首先我这个方法是一定可以调用的 因为它是继承下来的  这个方法是在哪里定义的
        //这个方法是在父类当中定义的    methodFu()其实子类里面没定义  定义在父类当中  这是属于父类的
        //只不过你拿不去 也能继承使用  但是属于谁呢 属于这个父类
        //在这种情况下  你觉得它输出的是子类的200呢？  还是父类的100呢？
        zi.methodFu();//结果是 100
    }

}

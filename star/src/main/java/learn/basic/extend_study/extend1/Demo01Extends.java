package learn.basic.extend_study.extend1;


/**
 * 面向对象的三大特征：封装性，继承性，多态性。
 *     extend  --继承  扩展
 *
 *      继承是多态的前提，如果没有继承，就没有多态。
 *
 *       继承主要解决的问题是 【共性抽取】   在上边来一个父类  把公共的东西都抽到上面   父类有的  子类继承了都自动拥有它们   当然子类也可以具有一些自己个性化  专有的方法
 *
 *       被继承 ---- 父类   基类    超类        --师父
 *       继承   ---- 子类          派生类       --徒弟      师父会多少武功，大徒弟也都会，小徒弟也都会。
 *
 *    继承当中的特点：
 *        1.子类可以拥有父类的 “内容”    ---是可继承的内容
 *        2.子类还可以拥有自己专有的新内容。
 */


/**
 * 在继承关系中， 请记住一句话   “子类就是一个父类 ”   也就是说子类可以被当作父类看待。
 *
 * 例如  父类是员工  子类是讲师， 那么  “讲师就是一个员工”  这不就是子类就是一个父类吗？   关系：is-a  一个讲师就是一个员工
 *
 *
 * 定义父类的格式：（一个普通的类定义）
 *
 * public class 父类名称{  就是一个普通类 没有任何区别
 *     //. . .
 * }
 *
 * 定义子类的格式：
 *
 * public class  子类名称 extends  父类名称{
 *
 * }
 *
 */
public class Demo01Extends {

    public static void main(String[] args) {

        //创建了一个子类对象
        Teacher  teacher = new Teacher();
        //此时当该教师子类什么都没写的时候    用来验证是否可以调用继承下来的内容
        //Teacher类当中虽然什么都没写，但是会继承来自父类的method方法。
        teacher.method();  //输出  方法执行！

        //但是可能会说  你这有什么好处呢  你不就  teacher.method() 了吗    我不用你这个父类  我就用我Teacher自己  那不挺好的吗  现在反而复杂了
        //举例  现在只有一个   子类教师  但是如果我再来一个  子类助教呢

        //此时当该助教子类什么都没写的时候
        //创建另一个子类助教的对象
        Assistant assistant = new Assistant();
        assistant.method();//输出  方法执行！   方法执行！
        //这说明什么  说明我们已经通过父类Employee写上一个方法 从而达到两个子类当中都有这个方法  达到了一种代码复用的结果
        //这就是我们在继承关系当中 代码里面父类定义和子类定以它各自的格式


    }



}

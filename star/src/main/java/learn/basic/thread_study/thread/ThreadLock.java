package learn.basic.thread_study.thread;

/**
 * 线程锁：
 *
 */
public class ThreadLock {

/******************基础知识***************************/
    /**
     * 线程状态：
     *      1.new :  新建
     *      2.Runnable: 就绪
     *      3.Running: 运行
     *      4.block: 阻塞
     *      5.dead：死亡
     *  线程状态转化：
     *      1.wait  挂起，会释放锁    wait方法的使用必须在同步的范围内，因为wait需要用到monitor的所有权，如果不是同步代码，是没有monitor所有权的
     *      2.notify  唤醒当前monitor持有者线程
     *      3.notifyAll 唤醒所有wait的线程
     *      4.sleep 当前线程暂停 不执行操作 而且不会释放锁（与wait的区别）
     *      5.yield 暂停当前线程，然后重新进行锁的竞争   主动让出cpu时间片
     *   各种锁概念：
     *      1.公平锁  锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO
     *      2.非公平锁
     *          自旋锁；让当前线程不停的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区
     *          阻塞锁：阻塞锁，可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间）时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态
     *          可重入锁： 指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响
     */


/******************关键字***************************/

    /**
     * Synchronized
     *
     *
     *
     *
     *
     */
}

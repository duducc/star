package learn.basic.classobject_study;

import com.sun.org.apache.xerces.internal.dom.PSVIAttrNSImpl;
import com.sun.org.apache.xpath.internal.SourceTree;

/**
 * 类和对象  知识点
 *
 *
 */
public class ClassAndObj {

    /**
     *
     * Java 语言来模拟现实世界的事物  怎么进行模拟呢
     *
     * 第一点
     *   什么是类- - -
     *
     *
     *      类 ：是一组相关 （属性）和（行为）的集合，可以看成是（一类事物）的（模板），使用事物的（属性特征）和（行为特征）来描述该类的事物
     *
     *      ·属性：就是该事物的状态信息   也就是 你 是什么
     *      ·行为：就是该事物能够做什么   能做 什么
     *           举例 ：  小猫     属性：名字  体重   年领  颜色
     *                            行为：走  跑  叫
     * 第二点
     *  什么是对象- - - -
     *
     *
     *     对象：是一类事物的（具体体现）。对象是类的一个（实例），必然具备该类事物的属性和行为
     *         现实中，一类事物的一个实例：如 一只小猫。
     *
     *  类与对象的关系----
     *     类是对一类事物的描述，是抽象的  就是不够具体  与具体是反义词
     *     对象是一类事物的实例，是具体的   就是类的具体化实例
     *
     *       例如   ipone 6s 手机的设计图（抽象的）    具有既有它的属性信息  又有它的行为信息  但是一张图纸  你能不能拿过来打电话  不能  手机的设计图是抽象的  它只是一个描述而已
     *                                                我说你是什么 我说你能做什么   但是它是个假的   这就叫做抽象的
     *              什么是真正的呢
     *
     *              生产出来的手机  真正的手机（具体的） 看的见 摸的着   它呢就是一个具体的    它就实现了图纸中的要求  长宽高  确实可以打电话
     *
     *              类  其实就是一个设计图   抽象的        但是具体的    （真正的手机）   就是根据类创建出来的对象    正儿八经的实现了功能  类是虚的
     *
     *               因此  通常情况下  想实现图纸当中的功能    就得根据图纸创建手机
     *                同理  如果想实现类当中的功能  通常情况下 也要根据一个抽象的类来实例化一个具体的对象        这里实例化  就是创建
     *
     *     类是对象的模板，对象是类的实体
     *
     *     类就是对显示世界事物的一个模拟
     */



    /**
     * 类的定义
     *
     *   事物与类的对比
     *
     *     属性 ： 事物的状态信息
     *     行为 ： 事物能够做什么
     *
     *    java 中用class描述事物也是如此：
     *
     *      成员变量： 对应事物的属性
     *      成员方法： 对应事物的行为  是没有static 关键字修饰的    例  public void  eat(){}
     *
     *   注意事项
     *     1.成员变量是直接定义在类当中的，在方法的外边  方法外
     *     2.成员方法不要写static关键字
     *
     */


    /**
     * 类的使用
     *    通常一个类不能直接使用，需要根据类创建一个对象，才能使用。  手机设计图无法使用  需要根据图纸创建一个手机才可以使用
     *
     *    如果来创建一个对象呢
     *    1。导包   也就是指出需要使用的类  在什么位置。
     *       格式：  import(关键字) 包名称.类名称；
     *       对于和当前类属于同一个包的情况  ，可以省略导包语句不写   是邻居 住在同一个包  不要导包 因为 即使导包 也是同一个包 同一个语句
     *
     *    2. 创建
     *        格式：类名称  对象名 = new 类名称();
     *              Student stu = new Student();  这就是根据Student（学生）类来创建一个stu的对象
     *
     *
     *    3. 使用  分为两种情况
     *
     *      如何使用成员变量 对象名.成员变量名
     *      如何使用成员方法 对象名.成员方法名(参数)
     *      （也就是，想用谁，就用对象名点儿谁）
     *
     *   注意事项
     *      成员变量不赋值 它有默认值   引用类型  为null
     *                                 int 是整数  为 0
     *                                       小数  为0.0
     *                                     字符是   /u0000
     *                                     Boolean  为false
     *      //改变对象当中成员变量数值内容
     *
     *      对象名.属性名=赋值   例  stu.name="典韦"    这是什么意思呢  就是把典韦这个字符串给它赋值交给stu对象当中的name成员变量
     *
     *
     */


    /**
     *   一个对象的内存图
     *      栈（stack）
     *
     *
     *      堆（heap）
     *
     *
     *      方法区（method Area）
     *         在你运行main方法之前  方法区要最先有数据  有什么数据  方法区保存的是.class相关数据
     *         那你现在有几个.class相关数据
     *         有两个 一个是  Phone.class{
     *                           //成员变量
     *                           String brand;
     *                           double price;
     *                           String color;
     *
     *
     *                          //成员方法
     *                           void call(String who);
     *                           void sendMessage();
     *                      }
     *               一个是  Demo01PhoneOne.class{
     *
     *                        main(String[] args)
     *
     *                      }
     *
     *          那现在两个.class相关信息都在方法区当中   你说从谁开始
     *
     *            谁有main方法就从谁开始   我需要先来运行main方法 main方法要想运行 就得进栈了   进入栈空间  进入栈空间的动作也叫压栈  进来以后做了什么事
     *                                     看main方法第一句代码  创建了一个对象  Phone  one = new Phone()   等号左边就好比是一个局部变量 我们说了  对象名称其实就是一个变量名称
     *                                     那你看它是在main大括号里面   这就好比是一个局部变量  那变量就势必就是来保存一些内容的  保存的是什么东西呢  你往里面赋值 赋的是个啥
     *                                     就要往右边看  发现 new 了吧  new了一个Phone  new了的东西全都在堆当中  凡是new出来的都在堆里面  画上一个方框   这次创建的可不是数组了
     *                                     创建的是一个对象  那是什么类型的对象呢  名称写上了  new了一个Phone  我怎么知道Phone这个类里面有什么内容呢  在那里存着  在方法区存着
     *                                     Phone.class就告诉你有什么成员变量  什么成员方法     那这个时候就可以把成员变量  参考着拿过来放到堆里面
     *                                     并且给他们赋上一些默认值   null  0.0  null   成员变量就好了  这些东西null  等默认值 就在堆中
     *
     *
     *
     *                                     成员方法怎么办  对于一个对象来说  它的成员方法保存的其实是一个地址值 比如 0x333
     *                                     当你去创建对象的时候方法区当中这个Phone.class  中的方法  它们的地址值将会保存在你的堆当中  然后指向方法区当中的方法
     *
     *
     *                                     成员变量是参考着方法区的Phone.class中成员变量 在堆中创建  并赋值  都存在堆中  值保存在哪里  就保存在堆里面  0.0  就在堆里面
     *                                     但是堆当中的成员方法 保存的是一个地址值 指向了方法区（Phone.class）当中的方法
     *                                      那现在 堆里面的 成员变量有了    成员方法有了   现在我自己也需要有一个地址  例地址值为0x666
     *                                      那么当你去进行赋值的时候  把右边的new赋值给左边的one   其实就是把 堆里面的地址值0x666保存在栈当中的one当中
     *                                      然后 栈当中的one  依据地址值指向堆里面的  new Phone();  根据地址 我就能找到这个对象
     *                                      那么现在我要访问一下 one.brand
     *                                                          one.price
     *                                                          one.color
     *                                                              one就会 根据地址值找到并访问到了 堆里面赋值有默认值的成员变量
     *
     *                                                      那现在我要对堆里面的成员变量赋值
     *                                                         例    one.brand="苹果"  怎么就变了呢
     *                                                          首先根据one 我能知道  你的地址是多少  然后找到堆里面相同的成员变量
     *                                                          当前是一个默认值null   我不要了    重新给他赋值为  我要成为的值或结果  “苹果”
     *                                                         这就改变了成员变量  当你再访问的时候  刚才赋值的信息就可以出来了  但是还没有完
     *                                                         因为还有2个方法的调用   one.call("乔布斯")
     *                                                         根据one 可以找到地址 0x666  但是call是一个方法     当根据地址找到堆里面的对象  之后根据方法区的地址 找到方法区的call方法
     *                                                         call方法要想运行 就要进栈  在栈给你画一个小方格  这个进栈 为什么叫做压栈
     *                                                         因为这个main方法是先来的  先来的人在底下  后来的人  后来居上  也就是说谁的后面就会把之前的人压在脚底下  所以叫做压栈
     *                                                         那call()方法要做什么事情呢  就是我要给谁打电话 System.out.println("给"+who+"打电话");  看参数是谁  就给谁打电话
     *                                                         看方法的参数是乔布斯吧 就给乔布斯打电话    这是根据方法的调用来的
     *                                                         在栈中main方法中的one.call()指向了刚才进栈的call()方法  你调用的是call()那我就找到这个call让它运行一把
     *                                                         给乔布斯打电话 打完了   没事了  call()方法就完成了    这个时候call()就会出栈  也叫做弹栈  call() 已经完了会立刻从栈区消失
     *                                                         但是刚才的main方法还没有完  后面还有东西呢
     *                                                         one.sendMessage()
     *                                                         我们也让它进栈  执行完里面的程序之后  然后出栈  运行完之后会立马出栈
     *
     *                                                         在这个时候main()方法也运行完了 那么它就会出栈了  main()方法都已经停止了 所有的内存都已经消失不见  程序就停了下来
     *
     *                                                         这就是我们在创建对象  设置属性   调用方法  栈内存  堆内存  方法区所发生的事情
     *
     *
     */



    /**
     * 两个对象使用同一个方法的内存图
     *
     *
     *   前面创建的一个对象的情况  内存情况肯定不会发生改变
     *      这次在创建第二个Phone对象
     *
     *      Phone two = new Phone();
     *
     *       System.out.println(two.brand);
     *       System.out.println(two.price);
     *       System.out.println(two.color);
     *
     *       ==========================   运行后是  默认值 null 0.0 null
     *
     *       two.brand="三星"；
     *       two.price="5999.0";
     *       two.color="蓝色";
     *
     *       System.out.println(two.brand);
     *       System.out.println(two.price);
     *       System.out.println(two.color);
     *
     *      ==========================   运行后是  三星 5999.0 蓝色
     *       two.call("欧巴")；
     *       two.sendMessage();
     *
     *
     *       这次不一样是因为  不是一个对象  是两个对象
     *
     *       栈：
     *
     *
     *       堆：
     *
     *
     *       方法区：  谁最先有东西呢  就是方法区
     *       这个Phone.class和刚才是一样的   例  Phone.class{
     *                                         //成员变量。。。
     *
     *                                         //成员方法。。。
     *
     *                                         如上
     *
     *                                      }
     *
     *                                      Demo01PhoneOne.class{
     *
     *                                               main(String[] args)
     *
     *                                               //如上
     *
     *                                      }
     *
     *
     *                                      此时这是第一个创建的one引用的Phone对象  如同上面
     *
     *
     *                                      此时内存请情况如上面的不变
     *
     *     但是现在又创建了一个two对象     是一个局部变量 就会在栈内存里面   然后再里面又new了吧    只要是new的东西都在堆当中  再画一个方框（相当于一个内存空间）
     *
     *        这个时候它还是会依据方法区的Phone.class{}中的成员变量 再如同上面再参考着来一份  并赋值默认值  并且  堆当中的成员方法  保存的还是和上面一样  0x333  方法区方法的地址
     *        此时堆里面的两个对象的成员方法地址都指向了方法区当中（同一块空间）的方法  当然地址也是一样的
     *        当然two对象也有自己的地址 如0x999
     *        那这个时候就需要对0x999你（two引用）赋值（即栈区的two保存了堆当中的对象的地址值   two引用也指向了堆当中的对象）
     *        接下来程序执行的 成员变量赋值    调用方法（调用谁我就让哪个方法进栈）    进栈  执行完毕消失  出栈   都是如同上面一样的       只要方法运行结束 立刻从栈内存当中消失   最后main()  没有代码了    执行完毕 出栈 消失
     *        整个程序就会停下来
     *
     *        第一个对象  我new了  第二个我也new了   你是你   我是我  怎么玩
     *        这两个对象 井水不范和河水  它们是独立的    两个没有产生任何联系   因为创建了 不同对象
     *
     *
     *        那这个时候如果我们想让他们有联系呢   我们只需要改一行代码
     *
     *        另外一种情况：
     *
     *           Phone two = one;
     *           让two 从 one那里拿一个东西过来  实际当中 将one保存的地址值赋值给了two
     *
     *           那此时运行代码  会发现  one  的代码结果没有区别   two   运行的代码 成员变量输出的是one的值
     *           此时two不是新的  是one玩剩下的二手货
     *
     *           那内存当中发生了什么事呢让它的结果不一样呢
     *
     *           同样的   三块内存  栈
     *
     *                             堆
     *
     *                             方法区    还是和刚才一样  没有变  Phone.class{
     *                                                                        //....
     *                                                             }
     *           main方法中的前面代码执行的都是一样的 和前面  没有区别   参考来一份  成员变量赋值   引用地址指向  方法调用   进栈  出栈  消失
     *
     *            直到运行到
     *                 Phone two = one;     这行代码之后
     *
     *                 这个two不是新new出来的 是从one当中把值拿过来的  它在堆里面也有一个小方格（即一块空间）  但是方格里面的东西是怎么来的
     *                 是根据你这个one往里赋值来的（即假如此时的one引用指向的地址值是0x666  那么two也就是0x666） 既然地址一样  我们两个可以找到同一个对象
     *                 我也能指向它（new  Phone()） 这次咋俩指向的是同一块了
     *                 那这个时候我再打印（syso(...)）的时候可不是新对象了  因此输出的就是one引用对象之前的赋值数据
     *                 那我可不可以改呢 当然可以    重新赋值之后  当然数据就是修改之后的数值了  再打印当然就是你修改的了
     *                 最后两行不能忘记
     *
     *
     *                 （俩个对象的名称指向了同一个对象）
     *                     代码执行的流程  还是同上面一样的   不同的是  调用方法的时候 用的是堆当中同一个对象的成员方法保存的地址  因为本来它也就指向的是同一个对象  无非是传的参数不同而已
     *                     其他的进栈  执行 出栈 都是一样的  到最后main方法已经没有更多代码了 main 也要出栈  一旦mian出栈   整个程序就会停下来  所有的内存也就全都没有了       对象名称  也叫做对象的引用  所一俩个对象的引用指向了同一个空间
     *
     */

    /**
     * 使用对象类型作为方法的参数
     *
     * public static void main(String[] args) {
     *     Phone one = new Phone()
     *     one.brand="苹果";
     *     one.price="8388.0";
     *     one.color="土豪金";
     *
     *     method(one)//传递进去的参数其实就是地址值
     *
     *     下面mentho（Phone param）  中的param 收到的也是地址值
     * }
     *
     *
     * public static void  method(Phone param){
     *
     * }
     *
     * 在内存的当中同上  区别是在  这次的method（Phone param） 方法在Demo04PhoneParam.class{}当中   当main()方法执行完毕的时候  会接着执行method
     * method()就进栈  同时传递参数--是地址值  例0x666   那么在method()方法的内部 就可以指向这个对象并进行赋值 调用等操作
     *
     * 当一个对象作为参数，传递到方法中时  真正 实际上传递进去的时对象的 (地址值)
     * 也就是说任何数据类型都能够作为方法的参数往里传递  而如果要是说你这个是一个数组或者是一个对象一个类的话 那么真正传递进去的是类似0x666这样的地址值
     * 有了地址值你就想用谁 就点（.）谁
     *
     */

    /**
     * 使用对象类型作为方法的返回值
     * public static void main(String[] args) {
     *     Phone two = getPhone()
     *     System.out.println(two.brand);
     *     System.out.println(two.price);
     *     System.out.println(two.color);
     * }
     *
     * public static Phone getPhone(){
     *     Phone one = new Phone();
     *     one.brand="苹果";
     *     one.price="8388.0";
     *     one.color="玫瑰金"
     *
     *     return one;
     *
     * }
     *
     * Demo05PhoneReturn.class{
     *     void main(String[] args)
     *     Phone getPhone();
     *
     *
     * }
     *
     * 在方法区当中会加载两个类  Phone.class{
     *
     *                         }
     *
     *                         Demo05PhoneReturn.class{
     *
     *                         }
     *
     *                         首先Demo05PhoneReturn.class中的main()方法会进栈  然后再栈当中为main（）开辟一块内存空间  执行代码      先在栈当中  开辟空间为Phone two
     *                          =getPhone(); 等号有右边是赋值   接下来调用getPhone()的方法  该方法进栈  同样会为此方法开辟一块内存空间    执行代码  Phone one = new Phone();
     *                                                         这个时候会在刚才方法区当中内存空间  为Phone one 开辟一块空间   右边的 new  Phone() 会在堆当中参考方法区中成员变量
     *                                                         再来一份  成员方法保存方法区方法地址值     之后会将刚才创建的对象的地址值保存在刚才的  Phone one当中
     *                                                         这个时候进行赋值完毕之后  return 会将刚才对象的地址值返回   也就是说那里调用 我就将地址值返回到那里
     *                                                         然后在main（）方法当中的getPhone();就是一个地址值  赋值给了  Phone  two  也就是保存的是刚才返回的地址值
     *                                                         这样就可以找到并指向堆当中的对象了  然后就可以获取它的属性  调用方法等一系列操作
     *
     *
     *                      总结：：
     *                          当使用一个对象类型作为方法的返回值时，返回值其实就是对象的地址值
     *
     *
     *      其实和上面的时类似的
     */

    //注意事项  在不同的包下是可以有相同名称的类

}
